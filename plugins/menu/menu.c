#include <stdlib.h>
#include <string.h>
#include <dirent.h>

#include <gdk-pixbuf/gdk-pixbuf.h>
#include <glib.h>
#include <glib/gstdio.h>

#include "panel.h"
#include "misc.h"
#include "plugin.h"
#include "bg.h"
#include "gtkbgbox.h"
#include "run.h"
#include "menu.h"

//#define DEBUGPRN
#include "dbg.h"

xconf *xconf_new_from_systemmenu();
gboolean systemmenu_changed(time_t btime);
static void menu_create(plugin_instance *p); 
static void menu_destroy(menu_priv *m);
static gboolean check_system_menu(plugin_instance *p);
static gboolean rebuild_menu(plugin_instance *p);

/* Copies original config while replacing specific entries
 * with autogenerated configs */
static xconf *
menu_expand_xc(xconf *xc, menu_priv *m)
{
    xconf *nxc, *cxc, *smenu_xc;
    GSList *w;

    ENTER;
    if (!xc)
        RET(NULL);
    nxc = xconf_new(xc->name, xc->value);
    DBG("new node:%s\n", nxc->name);
    for (w = xc->sons; w; w = g_slist_next(w))
    {
        cxc = w->data;
        if (!strcmp(cxc->name, "systemmenu"))
        {
            smenu_xc = xconf_new_from_systemmenu();
            xconf_append_sons(nxc, smenu_xc);
            xconf_del(smenu_xc, FALSE);
            m->has_system_menu = TRUE;
            continue;
        }
        if (!strcmp(cxc->name, "include"))
        {
            smenu_xc = xconf_new_from_file(cxc->value, "include");
            xconf_append_sons(nxc, smenu_xc);
            xconf_del(smenu_xc, FALSE);
            continue;
        }
        xconf_append(nxc, menu_expand_xc(cxc, m));
    }
    return nxc;
}

#if 0
/* XXX: should be global service with following API
 * register_command, unregister_command, run_command
 */
static void
run_command(GtkWidget *widget, void (*cmd)(void))
{
    ENTER;
    cmd();
    RET();
}
#endif

static GtkWidget *
menu_create_separator()
{
    return gtk_separator_menu_item_new();
}

/* Creates menu item. Text and image are read from xconf. Action
 * depends on @menu. If @menu is NULL, action is to execute external
 * command. Otherwise it is to pop up @menu menu */
static GtkWidget *
menu_create_item(xconf *xc, GtkWidget *menu, menu_priv *m)
{
    gchar *name, *fname, *iname, *action, *cmd;
    GtkWidget *mi;

    cmd = name = fname = action = iname = NULL;
    XCG(xc, "name", &name, str);
    mi = gtk_image_menu_item_new_with_label(name ? name : "");
    gtk_container_set_border_width(GTK_CONTAINER(mi), 0);
    XCG(xc, "image", &fname, str);
    fname = expand_tilda(fname);
    XCG(xc, "icon", &iname, str);
    if (fname || iname)
    {
        GdkPixbuf *pb;

        if ((pb = fb_pixbuf_new(iname, fname, m->icon_size, m->icon_size,
                    FALSE)))
        {
            gtk_image_menu_item_set_image(GTK_IMAGE_MENU_ITEM(mi),
                    gtk_image_new_from_pixbuf(pb));
            g_object_unref(G_OBJECT(pb));
        }
    }
    g_free(fname);

    if (menu)
    {
        gtk_menu_item_set_submenu(GTK_MENU_ITEM(mi), menu);
        goto done;
    }
    XCG(xc, "action", &action, str);
    if (action)
    {
        action = expand_tilda(action);

        g_signal_connect_swapped(G_OBJECT(mi), "activate",
                (GCallback)run_app, action);
        g_object_set_data_full(G_OBJECT(mi), "activate",
            action, g_free);
        goto done;
    }

    XCG(xc, "rebuildmenu", &cmd, str); // FIXME
    if (cmd)
    {
        g_signal_connect_swapped(G_OBJECT(mi),
            "activate", (GCallback) rebuild_menu, m);
    }

    XCG(xc, "command", &cmd, str);
    if (cmd)
    {
        /* XXX: implement command API */
#if 0
        command *tmp;
        
        for (tmp = commands; tmp->name; tmp++)
            if (!g_ascii_strcasecmp(cmd, tmp->name))
            {
                g_signal_connect(G_OBJECT(mi), "activate",
                        (GCallback)run_command, tmp->cmd);
                goto done;
            }
#endif        
    }
   
done:
    return mi;
}



//#define _BSD_SOURCE
#define _USE_SCANDIR
// FIXME this should make configure script

typedef struct {
    gchar *path;
    char *cmd;
    char *url_cmd;
    char *edit_cmd;

    char *name;
    char *icon;
    GdkPixbuf *default_icon;
    GdkPixbuf *default_dir_icon;

    gboolean base_level;
    gboolean use_desktop_files;
} direntry_conf;

static void direntry_conf_free(direntry_conf *ptr) {
    ENTER;

    DBG("free path=%s base_level=%d\n", ptr->path, ptr->base_level);

    g_free(ptr->path);
    if (ptr->base_level) {
        if (ptr->cmd) free(ptr->cmd);
        if (ptr->url_cmd) free(ptr->url_cmd);
        if (ptr->edit_cmd) free(ptr->edit_cmd);
        if (ptr->default_icon && G_IS_OBJECT(G_OBJECT(ptr->default_icon))) {
            g_object_unref(G_OBJECT(ptr->default_icon));
        }
        if (ptr->default_dir_icon && G_IS_OBJECT(G_OBJECT(ptr->default_dir_icon))) {
            g_object_unref(G_OBJECT(ptr->default_dir_icon));
        }
    }

    free(ptr);

    RET();
}

static char* get_val(char *buf, int len) {
    char *val;

    ENTER;

    if (buf[len-1]=='\n') {
        buf[len-1]='\0';
    }
    val = index(buf, '=') + 1;
    val = strdup(val);

    RET( val );
}
static void parse_desktop_file(char* filename, char** name, char** icon, char** action, char** url) {
    FILE *f;
    char buf[1024];
    int len;

    ENTER;

    DBG("Read file %s\n", filename);
    f = fopen(filename, "r");
    if (f) {
        while( fgets(buf, 1024, f) ) {
            DBG("Line: %s\n", buf);

            len=strlen(buf);
            DBG("Line lenght = %d\n", len);
            if (len > 1022) {
                ERR("Line too long!\n");
                fclose(f);
                RET();
            }

            if (name && strncmp(buf, "Name", 4) == 0)
                *name = get_val(buf, len);
            else if (icon && strncmp(buf, "Icon", 4) == 0)
                *icon = get_val(buf, len);
            else if (action && strncmp(buf, "Exec", 4) == 0)
                *action = get_val(buf, len);
            else if (url && strncmp(buf, "URL", 3) == 0)
                *url = get_val(buf, len);
        }
        fclose(f);
    }

    RET();
}

static GtkResponseType
entry_dialog_create(const char *title, const char *value, char **valuenew, const char *add_buton)
{
    GtkDialog *dialog;
    GtkEntry *text;

    ENTER;

    dialog = (GtkDialog*) gtk_dialog_new_with_buttons (title, NULL,
                                           GTK_DIALOG_MODAL | GTK_DIALOG_DESTROY_WITH_PARENT,
                                           GTK_STOCK_OK,      GTK_RESPONSE_OK,
                                           GTK_STOCK_CANCEL,  GTK_RESPONSE_CANCEL,
                                           NULL);
    gtk_dialog_set_default_response(dialog, GTK_RESPONSE_OK);

    if (add_buton)
        gtk_dialog_add_button(dialog, add_buton, 1);

    text = (GtkEntry*) gtk_entry_new();
    gtk_entry_set_activates_default(text, TRUE);
    gtk_entry_set_text(text, value);
    gtk_box_pack_start (GTK_BOX(gtk_dialog_get_content_area(dialog)),
        GTK_WIDGET(text), TRUE, TRUE, 0);
    gtk_widget_show (GTK_WIDGET(text));

    gint result = gtk_dialog_run (dialog);
    *valuenew = strdup(gtk_entry_get_text(text));

    DBG("dialog result: %d %s\n", result, *valuenew);

    gtk_widget_destroy (GTK_WIDGET(dialog));

    RET(result);
}

static void run_app_with_arg(const char *app, const char *arg) {
    gchar *buf;

    ENTER;

    buf = g_strdup_printf("%s \"%s\"", app, arg);
    run_app(buf);
    g_free(buf);

    RET();
}

static gint
direntry_button_press_event(GtkWidget * widget, GdkEventButton * event, direntry_conf *dec)
{
    char *buf, *tmp, *new_path, *cmd, *url;
    int result;

    ENTER;
    if (event->type != GDK_BUTTON_PRESS)
        RET(FALSE);

    DBG("button=%d cmd=%s (%p), path=%s (%p)\n", event->button, dec->cmd, dec->cmd, dec->path, dec->path);

    if (event->button == 1 && dec->cmd) {
        cmd = url = NULL;
        if (dec->use_desktop_files == TRUE) {
            tmp = rindex(dec->path, '.');
            if (tmp && strcmp(++tmp, "desktop") == 0) {
                parse_desktop_file(dec->path, NULL, NULL, &cmd, &url);
                DBG("is .desktop file with Exec=%s Url=%s\n", cmd, url);
            }
        }

        if (cmd) {
            run_app(cmd);
        } else if (url && dec->url_cmd) {
            run_app_with_arg(dec->url_cmd, url);
        } else if (dec->cmd) {
            run_app_with_arg(dec->cmd, dec->path);
        }
    } else if (event->button == 3) {
        tmp = rindex(dec->path, '/');
        result = entry_dialog_create("Rename to:", tmp + 1, &buf, "Edit as text file");

        if (result == GTK_RESPONSE_OK) {
            *tmp = '\0';
            new_path = g_strdup_printf("%s/%s", dec->path, buf);
            *tmp = '/';

            DBG("rename %s to: %s\n", dec->path, new_path);
            rename(dec->path, new_path);

            g_free( dec->path );
            dec->path = new_path;

            if (dec->use_desktop_files == TRUE) {
                tmp = rindex(new_path, '.');
            } else {
                tmp = NULL;
            }
            if ( tmp == NULL || strcmp(++tmp, "desktop") ) {
                gtk_menu_item_set_label(GTK_MENU_ITEM(widget), buf);
            }
        } else if (result == 1 && dec->edit_cmd) {
            run_app_with_arg(dec->edit_cmd, dec->path);
        }

        free(buf);
    }
    RET(FALSE);
}

gchar * expand_tilda_and_dot(gchar *file, gchar *path) {
    ENTER;
    if (!file)
        RET(NULL);
    if (file[0] == '~')
        RET( g_strdup_printf("%s%s", getenv("HOME"), file+1) );
    if (file[0] == '.')
        RET( g_strdup_printf("%s%s", path, file+1) );
    RET( g_strdup(file) );
}

static void
set_direntry_item_name_and_icon(menu_priv *m, GtkImageMenuItem *mi,
                                direntry_conf *dec,
                                char *name, GdkPixbuf *icon)
{
    GdkPixbuf *icon_new = NULL;
    gchar *ficon;
    ENTER;

    if (dec->name) {
        DBG("setting name from dec\n");
        gtk_menu_item_set_label(GTK_MENU_ITEM(mi), dec->name);
        free(dec->name);
    } else {
        DBG("setting name from args\n");
        gtk_menu_item_set_label(GTK_MENU_ITEM(mi), name);
    }

    if (dec->icon) {
        DBG("setting icon from dec\n");
        ficon = expand_tilda_and_dot(dec->icon, dec->path);
        if ((icon_new = fb_pixbuf_new(dec->icon, ficon, m->icon_size, m->icon_size, FALSE)))
        {
            gtk_image_menu_item_set_image( mi, gtk_image_new_from_pixbuf(icon_new) );
            g_object_unref(G_OBJECT(icon_new));
        }
        g_free(ficon);
        free(dec->icon);
    }
    if (!icon_new && icon) {
        DBG("setting icon from args\n");
        gtk_image_menu_item_set_image(mi, gtk_image_new_from_pixbuf(icon));
    }

    RET();
}

static void
menu_create_direntry(xconf *xc, menu_priv *m, GtkWidget *menu, direntry_conf *dec)
{
    GtkWidget *mi;
    struct dirent *de;
    direntry_conf *newdec;
    gchar *path = NULL, *action = NULL, *fname = NULL, *iname = NULL;
    char *file_ext;

    ENTER;

    if (dec == NULL) {
        dec = calloc(1, sizeof(direntry_conf));
        DBG("read direntry config - paths\n");

        XCG(xc, "path", &path, str);
        if (path) {
            dec->path = expand_tilda(path);
        } else {
            dec->path = NULL;
        }

        XCG(xc, "action", &action, str);
        if (action) {
            dec->cmd = strdup(action);
        } else {
            dec->cmd = NULL;
        }

        dec->use_desktop_files = TRUE;
        XCG(xc, "UseDesktopFiles", &dec->use_desktop_files, enum, bool_enum);

        action = NULL;
        XCG(xc, "URLaction", &action, str);
        if (action) {
            dec->url_cmd = strdup(action);
        } else {
            dec->url_cmd = NULL;
        }

        action = NULL;
        XCG(xc, "EDITaction", &action, str);
        if (action) {
            dec->edit_cmd = strdup(action);
        } else {
            dec->edit_cmd = NULL;
        }

        DBG("read direntry config - icons\n");
        fname = iname = NULL;
        XCG(xc, "image", &fname, str);
        fname = expand_tilda(fname);
        XCG(xc, "icon", &iname, str);
        if (fname || iname) {
            dec->default_icon = fb_pixbuf_new(iname, fname, m->icon_size, m->icon_size, TRUE);
        } else {
            dec->default_icon = NULL;
        }
        g_free(fname);

        fname = iname = NULL;
        XCG(xc, "SubDirImage", &fname, str);
        fname = expand_tilda(fname);
        XCG(xc, "SubDirIcon", &iname, str);
        if (fname || iname) {
            dec->default_dir_icon = fb_pixbuf_new(iname, fname, m->icon_size, m->icon_size, TRUE);
        } else {
            dec->default_dir_icon = NULL;
        }
        g_free(fname);

        dec->base_level = TRUE;
        DBG("direntry config:\n");
        DBG("    path=%s, cmd=%s\n", dec->path, dec->cmd);
        DBG("    default_icon=%p, default_dir_icon=%p\n", dec->default_icon, dec->default_dir_icon);
        DBG("    use_desktop_files=%d url_cmd=%s , edit_cmd=%s\n", dec->use_desktop_files,
                 dec->url_cmd, dec->edit_cmd);
    }

#ifdef _USE_SCANDIR
    struct dirent **namelist;
    int n, i;
    n = scandir(dec->path, &namelist, 0, alphasort);
    if (n>0) {
        for (i=0; i<n; i++) {
            de = namelist[i];
#else
    DIR* d;
    d = opendir( dec->path );
    if (d) {
        while ( (de = readdir(d)) ) {
#endif
            DBG("parsing entry: %s/%s\n", dec->path, de->d_name);

            newdec = calloc(1, sizeof(direntry_conf));
            newdec->base_level = FALSE;

            newdec->use_desktop_files = dec->use_desktop_files;
            newdec->cmd = dec->cmd;
            newdec->url_cmd = dec->url_cmd;
            newdec->edit_cmd = dec->edit_cmd;

            newdec->path = g_strdup_printf("%s/%s", dec->path, de->d_name);

            if (de->d_name[0] == '.') {
                DBG("is dot-start file\n");
                if (dec->use_desktop_files == TRUE
                    && dec->base_level == FALSE
                    && strcmp(de->d_name, ".directory") == 0)
                {
                    parse_desktop_file(newdec->path, &dec->name, &dec->icon, NULL, NULL);
                }
                direntry_conf_free(newdec);
                continue;
            }

            if (de->d_type == DT_UNKNOWN) {
                // de->d_type not work for example on sshfs
                struct stat fi;
                stat(newdec->path, &fi);
                if( S_ISDIR(fi.st_mode) )
                    de->d_type = DT_DIR;
            }

            if (de->d_type == DT_DIR) {
                DBG("is directory\n");

                newdec->default_icon = dec->default_icon;
                newdec->default_dir_icon = dec->default_dir_icon;
                newdec->name = NULL;
                newdec->icon = NULL;

                mi = gtk_menu_new();
                gtk_container_set_border_width(GTK_CONTAINER(mi), 0);
                menu_create_direntry(xc, m, mi, newdec);
                gtk_widget_show_all(mi);
                mi = menu_create_item(xc, mi, m);

                DBG("finalize visual settings for submenu\n");
                set_direntry_item_name_and_icon( m, GTK_IMAGE_MENU_ITEM(mi), newdec,
                                                 de->d_name, dec->default_dir_icon );
                direntry_conf_free(newdec);
            } else {
                DBG("is file\n");
                mi = gtk_image_menu_item_new_with_label(de->d_name);
                gtk_container_set_border_width(GTK_CONTAINER(mi), 0);

                if (dec->use_desktop_files == TRUE) {
                    file_ext = rindex(de->d_name, '.');
                    if (file_ext && strcmp(++file_ext, "desktop") == 0) {
                        parse_desktop_file(newdec->path, &newdec->name, &newdec->icon, NULL, NULL);
                    }
                }

                DBG("finalize visual settings for item\n");
                set_direntry_item_name_and_icon( m, GTK_IMAGE_MENU_ITEM(mi), newdec,
                                                 de->d_name, dec->default_icon );

                DBG("setting action\n");
                g_signal_connect (G_OBJECT (mi), "button_press_event",
                     (GCallback) direntry_button_press_event, (gpointer)newdec);

                DBG("setting cleanup\n");
                g_object_set_data_full(G_OBJECT(mi), "activate",
                     newdec, (GDestroyNotify)direntry_conf_free);
            }
            gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);

#ifndef _USE_SCANDIR
        }
        closedir( d );
    }
#else
            free(de);
        }
    free(namelist);
    }
#endif

    if(dec->base_level) {
        DBG("setting cleanup for path\n");
        g_object_set_data_full(G_OBJECT(menu), "activate",
             dec, (GDestroyNotify)direntry_conf_free);
    }
    RET();
}



/* Creates menu and optionally button to pop it up.
 * If @ret_menu is TRUE, then a menu is returned. Otherwise,
 * button is created, linked to a menu and returned instead. */
static GtkWidget *
menu_create_menu(xconf *xc, gboolean ret_menu, menu_priv *m)
{
    GtkWidget *mi, *menu;
    GSList *w;
    xconf *nxc;
    
    if (!xc)
        return NULL;
    menu = gtk_menu_new ();
    gtk_container_set_border_width(GTK_CONTAINER(menu), 0);
    for (w = xc->sons; w ; w = g_slist_next(w))
    {
        nxc = w->data;
        if (!strcmp(nxc->name, "separator"))
            mi = menu_create_separator();
        else if (!strcmp(nxc->name, "item"))
            mi = menu_create_item(nxc, NULL, m);
        else if (!strcmp(nxc->name, "dir")) {
            DBG("parsing dir entry\n");
            menu_create_direntry(nxc, m, menu, NULL);
            continue;
        } else if (!strcmp(nxc->name, "menu"))
            mi = menu_create_menu(nxc, FALSE, m);
        else
            continue;
        gtk_menu_shell_append(GTK_MENU_SHELL(menu), mi);
    }
    gtk_widget_show_all(menu);
    return (ret_menu) ? menu : menu_create_item(xc, menu, m);
}

static gboolean
menu_unmap(GtkWidget *menu, plugin_instance *p)
{
    ENTER;
    if (p->panel->autohide)
        ah_start(p->panel);
    RET(FALSE);
}

static void
menu_create(plugin_instance *p)
{
    menu_priv *m = (menu_priv *) p;
    
    ENTER;
    if (m->menu)
        menu_destroy(m);
    m->xc = menu_expand_xc(p->xc, m);
    m->menu = menu_create_menu(m->xc, TRUE, m);
    g_signal_connect(G_OBJECT(m->menu), "unmap", 
        G_CALLBACK(menu_unmap), p);
    m->btime = time(NULL);
    if (m->has_system_menu) 
        m->tout = g_timeout_add(30000, (GSourceFunc) check_system_menu, p);
    RET();
}

static void
menu_destroy(menu_priv *m)
{
    ENTER;
    if (m->menu) {
        gtk_widget_destroy(m->menu);
        m->menu = NULL;
        m->has_system_menu = FALSE;
    }
    if (m->tout) {
        g_source_remove(m->tout);
        m->tout = 0;
    }
    if (m->rtout) {
        g_source_remove(m->rtout);
        m->rtout = 0;
    }
    if (m->xc) {
        xconf_del(m->xc, FALSE);
        m->xc = NULL;
    }
    RET();
}

static gboolean
my_button_pressed(GtkWidget *widget, GdkEventButton *event, plugin_instance *p)
{
    menu_priv *m = (menu_priv *) p;

    ENTER;
    /* propagate Control-Button3 to the panel */
    if (event->type == GDK_BUTTON_PRESS && event->button == 3
        && event->state & GDK_CONTROL_MASK)
    {
        RET(FALSE);
    }

    if ((event->type == GDK_BUTTON_PRESS)
        && (event->x >=0 && event->x < widget->allocation.width)
        && (event->y >=0 && event->y < widget->allocation.height))
    {
        if (!m->menu)
            menu_create(p);
        if (p->panel->autohide)
            ah_stop(p->panel);
        gtk_menu_popup(GTK_MENU(m->menu),
            NULL, NULL, (GtkMenuPositionFunc)menu_pos, widget,
            event->button, event->time);
       
    }
    RET(TRUE);
}


static void
make_button(plugin_instance *p, xconf *xc)
{
    int w, h;
    menu_priv *m;
    gchar *fname, *iname;
    
    ENTER;
    m = (menu_priv *) p;
    /* XXX: this code is duplicated in every plugin.
     * Lets run it once in a panel */
    if (p->panel->orientation == GTK_ORIENTATION_HORIZONTAL)
    {
        w = -1;
        h = p->panel->max_elem_height;
    }
    else
    {
        w = p->panel->max_elem_height;
        h = -1;
    }
    fname = iname = NULL;
    XCG(xc, "image", &fname, str);
    fname = expand_tilda(fname);
    XCG(xc, "icon", &iname, str);
    if (fname || iname)
    {
        m->bg = fb_button_new(iname, fname, w, h, 0x702020, NULL);
        gtk_container_add(GTK_CONTAINER(p->pwid), m->bg);
        if (p->panel->transparent)
            gtk_bgbox_set_background(m->bg, BG_INHERIT, 0, 0);
        g_signal_connect (G_OBJECT (m->bg), "button-press-event",
            G_CALLBACK (my_button_pressed), p);
    }
    g_free(fname);
}

static gboolean
rebuild_menu(plugin_instance *p)
{
    menu_priv *m = (menu_priv *) p;
    
    ENTER;
    if (m->menu && GTK_WIDGET_MAPPED(m->menu))
        RET(TRUE);
    menu_create(p);
    m->rtout = 0;
    RET(FALSE);
}

static void
schedule_rebuild_menu(plugin_instance *p)
{
    menu_priv *m = (menu_priv *) p;
    
    ENTER;
    if (!m->rtout) {
        DBG("scheduling menu rebuild p=%p\n", p);
        m->rtout = g_timeout_add(2000, (GSourceFunc) rebuild_menu, p);
    }
    RET();

}

static gboolean
check_system_menu(plugin_instance *p)
{
    menu_priv *m = (menu_priv *) p;
    
    ENTER;
    if (systemmenu_changed(m->btime)) 
        schedule_rebuild_menu(p);
    
    RET(TRUE);
}

static int
menu_constructor(plugin_instance *p)
{
    menu_priv *m;

    ENTER;
    m = (menu_priv *) p;
    m->icon_size = MENU_DEFAULT_ICON_SIZE;
    XCG(p->xc, "iconsize", &m->icon_size, int);
    DBG("icon_size=%d\n", m->icon_size);
    make_button(p, p->xc);
    g_signal_connect_swapped(G_OBJECT(icon_theme),
        "changed", (GCallback) schedule_rebuild_menu, p);
    schedule_rebuild_menu(p);
    RET(1);
}


static void
menu_destructor(plugin_instance *p)
{
    menu_priv *m = (menu_priv *) p;

    ENTER;
    g_signal_handlers_disconnect_by_func(G_OBJECT(icon_theme),
        schedule_rebuild_menu, p);
    menu_destroy(m);
    gtk_widget_destroy(m->bg);
    RET();
}


static menu_class class = {
    .plugin = {
        .count       = 0,
        .type        = "menu",
        .name        = "Menu",
        .version     = "1.0",
        .description = "Menu",
        .priv_size   = sizeof(menu_priv),

        .constructor = menu_constructor,
        .destructor  = menu_destructor,
    }
};

static plugin_class *class_ptr = (plugin_class *) &class;
